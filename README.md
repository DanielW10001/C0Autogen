# AutoGen

Reduced C0 Grammar Analyser and Code Generator
For BUAA Compiler Course

Daniel (danielw10001@gmail.com)
BUAA Dept.6 SCSE

[TOC]

## 1. Usage

- Dependency: Python 3.5+
- Create `in.txt`, `out.txt`, `err.txt` under project dir
- `py grammar.py`
    - `MAX_LOOP_INVOKE_NUMBER`: Control max loop invoke number
    - `str(Expr)`: Get Grammar Representation
    - `Expr.get_grammar_tree()`: Get Grammar Tree
    - `Expr.get_possibility_count()`: Get Possibility Count
    - `Expr.get_random_instance()`: Get Random Instance

## 2. BNF Grammar

- BNF语句中所使用的任何终结符必须包含在`'`或`"`中
- BNF语句中所定义和使用的任何非终结符必须包含在`<>`中
- 字面字符: `\", \', \<, \>, \(, \), \{, \}, \[, \], \|, 任何包含在', ", <>中的字符`
- 运算符 (优先级降序)
    - `"`, `'`: 终结符
    - `<>`: 非终结符
    - `()`: 子表达式
    - `{}`: 0-n次
    - `[]`: 0-1次
    - 空: 拼接
    - `|`: 或
        - 规则优先级降序

```bnf
<ExpressionA>::=<ExpressionB>{"|"<ExpressionB>}
<ExpressionB>::=<ExpressionC>{<ExpressionC>}
<ExpressionC>::="["<ExpressionA>"]"|"{"<ExpressionA>"}"|"("<ExpressionA>")"|"<"{<TerminateSymbol>}">"|"\"{<TerminateSymbol>}"\""|"\'"{<TerminateSymbol>}"\'"
```

## 3. Reduced C0 Grammar

- 按`{}`取0, 1, 2次出现, 递归一次计算, 本文法有9550944059270083642411036694017578933031420450597376264098264217286574159281629410270156156624486144680879090608007284568732595287516729104178632034968909195780059700016495938345183545347666976061178252511593617886301405329206988248673233689592984350078231391419254262170228542263901651566261891053478450415968785454176155023358319801780117999077576702051765180167067723822364336979992936497435624932497575994047436046941685497941457321131393336908956637052358133108007309822709056832812177235124550960482687188684861740855325952014401008686105973206017866770903337851859603242357339786590230201572481385144976239170852409937055050012675907250646926200400266656568636001439531648065554671482620120266498314998744833764327175402311594025655304377565592996813598303256530440110219338470810786368788035942752519345014262486235480302835663360137074890957161186293943563015651639694140538967042087178179025043516728370376403713620235060795154837243841501435737665338346704896282244553422037387532643896838730103698014433664229283925225040451562896216479165660884670356568404101913950648794686868557541705878423823434249912227036498579816024443685434206111461060812279663952174675868451935379459768741201685800333643761458765941050306840297472640979642862807843249134697149705145221526599223820133975182390056140228305502679953888480546501587656851267994757319573607529030625553735089205021239205334382063162353210183049145178777603314635370482714501217829947398312041933619863464078044475642662001990045853416481207860367318428621802122550251162202785976599558811157825198667111272759494166987195854945602989849442037779934565055988700115810552622203528074438288195276672898402866604415265167841517506152025539454161647422504093748877346737787432202215553352053214895622569617740121755394693253112067718185661078544110830647798528025种可能的`<程序>`
- 对`<标识符>`与`<字符串>`限定为`"标识符"`与`"字符串"`的`autogen_grammar`文法, 有347706154268625278083213328588265763527710612240360804349423094937353025018197933534374483741653689653396512273086096318826032614193917006327977708540032570027498855051350781728739601408687968221975672092634091423390745709894432571104740953594603980520670998684402950529198268319939275428954877905788139073867833186643280165597616216573606166305878794974635464413921892165292480607866185452064217422373630944039829942988400115449648701196663884970326359378464941557938927489608180938910952477737446568044179992653990996353641844255496912985931668259336383119029275734733367354327264813871590753950663774433564805061125418469072419840195877053223128972315763450051259331980105808778073789412203020957000652168964343717644520996003158502204988413480202180834962501143143657104157707353530365219427921082124323917428526472652861971496470392023355427807699047653048180799026848460492800种可能的`<程序>`

```bnf
<空>::=""
<加法运算符>::="+"|"-"
<乘法运算符>::="*"|"/"
<关系运算符>::="<"|"<="|">"|">="|"!="|"=="
<字母>::="_"|"a"|"b"|"c"|"d"|"e"|"f"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"n"|"o"|"p"|"q"|"r"|"s"|"t"|"u"|"v"|"w"|"x"|"y"|"z"|"A"|"B"|"C"|"D"|"E"|"F"|"G"|"H"|"I"|"J"|"K"|"L"|"M"|"N"|"O"|"P"|"Q"|"R"|"S"|"T"|"U"|"V"|"W"|"X"|"Y"|"Z"
<数字>::="0"|<非零数字>
<非零数字>::="1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
<字符>::="\'"<加法运算符>"\'"|"\'"<乘法运算符>"\'"|"\'"<字母>"\'"|"\'"<数字>"\'"
<字符串>::="\""{" "|"!"|"#"|"$"|"%"|"&"|"'"|"("|")"|"*"|"+"|","|"-"|"."|"/"|"0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"|":"|";"|"<"|"="|">"|"?"|"@"|"A"|"B"|"C"|"D"|"E"|"F"|"G"|"H"|"I"|"J"|"K"|"L"|"M"|"N"|"O"|"P"|"Q"|"R"|"S"|"T"|"U"|"V"|"W"|"X"|"Y"|"Z"|"["|"\\"|"]"|"^"|"_"|"`"|"a"|"b"|"c"|"d"|"e"|"f"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"n"|"o"|"p"|"q"|"r"|"s"|"t"|"u"|"v"|"w"|"x"|"y"|"z"|"{"|"|"|"}"|"~"}"\""
<程序>::=[<常量说明>][<变量说明>]{<有返回值函数定义>|<无返回值函数定义>}<主函数>
<常量说明>::="const"<常量定义>";"{"const"<常量定义>";"}
<常量定义>::="int"<标识符>"="<整数>{","<标识符>"="<整数>}|"char"<标识符>"="<字符>{","<标识符>"="<字符>}
<无符号整数>::=<非零数字>{<数字>}|"0"
<整数>::=["+"|"-"]<无符号整数>
<标识符>::=<字母>{<字母>|<数字>}
<声明头部>::="int"<标识符>|"char"<标识符>
<变量说明>::=<变量定义>";"{<变量定义>";"}
<变量定义>::=<类型标识符>(<标识符>|<标识符>"["<无符号整数>"]"){","(<标识符>|<标识符>"["<无符号整数>"]")}//<无符号整数>表示数组元素的个数,其值需大于0
<类型标识符>::="int"|"char"
<有返回值函数定义>::=<声明头部>"("<参数表>")""{"<复合语句>"}"
<无返回值函数定义>::="void"<标识符>"("<参数表>")""{"<复合语句>"}"
<复合语句>::=[<常量说明>][<变量说明>]<语句列>
<参数表>::=<类型标识符><标识符>{","<类型标识符><标识符>}|<空>
<主函数>::="void""main""("")""{"<复合语句>"}"
<表达式>::=["+"|"-"]<项>{<加法运算符><项>}//["+"|"-"]只作用于第一个<项>
<项>::=<因子>{<乘法运算符><因子>}
<因子>::=<标识符>|<标识符>"["<表达式>"]"|"("<表达式>")"|<整数>|<字符>|<有返回值函数调用语句>
<语句>::=<条件语句>|<循环语句>|"{"<语句列>"}"|<有返回值函数调用语句>";"|<无返回值函数调用语句>";"|<赋值语句>";"|<读语句>";"|<写语句>";"|<空>";"|<返回语句>";"
<赋值语句>::=<标识符>"="<表达式>|<标识符>"["<表达式>"]""="<表达式>
<条件语句>::="if""("<条件>")"<语句>["else"<语句>]
<条件>::=<表达式><关系运算符><表达式>|<表达式>//值为0为假,否则为真
<循环语句>::="while""("<条件>")"<语句>|"do"<语句>"while""("<条件>")"|"for""("<标识符>"="<表达式>";"<条件>";"<标识符>"="<标识符>("+"|"-")<步长>")"<语句>
<步长>::=<无符号整数>
<有返回值函数调用语句>::=<标识符>"("<值参数表>")"
<无返回值函数调用语句>::=<标识符>"("<值参数表>")"
<值参数表>::=<表达式>{","<表达式>}|<空>
<语句列>::={<语句>}
<读语句>::="scanf""("<标识符>{","<标识符>}")"
<写语句>::="printf""("<字符串>","<表达式>")"|"printf""("<字符串>")"|"printf""("<表达式>")"
<返回语句>::="return"["("<表达式>")"]
```

- 不能使用未声明变量/函数
    - 声明在使用的源代码之后也不行

## 4. 循环递归

- 循环: 表达式 -> 项 -> 因子 -> 表达式
- 解决: 记录递归次数, 第二次递归调用时`ExprCAB <Identifier> -> ExprCQ "Identifier"`
